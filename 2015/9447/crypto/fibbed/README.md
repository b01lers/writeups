# 9447 : Fibbed

#### Author: GSAir

**Description**:
> Some secret communication was captured, and we're having trouble decrypting it. Can you help?

First from the pcap file, we just extract the data exchanged by the client and server.

    981725946171163877
    58449491987662952,704965025359609904
    453665378628814896,152333692332446539
    59719af4dbb78be07d0398711c0607916dd59bfa57b297cd220b9d2d7d217f278db6adca88c9802098ba704a18cce7dd0124f8ce492b39b64ced0843862ac2a6

The line 1, 2 and 4 are in the direction server to client and the line 3 is from client to server.

Time to look at the source code, we put here the important part only:

Server:

    FLAG = ""
    IV = "0123456789ABCDEF"

    def encrypt(message, passphrase):
        key = hashlib.sha256(passphrase).digest()
        aes = AES.new(key, AES.MODE_CBC, IV)
        message += "\x00" * (16 - len(message) % 16)
        return binascii.hexlify(aes.encrypt(message))

    class ServerHandler(SocketServer.BaseRequestHandler):

        def handle(self):
            p = fibCrypt.genPrime(8);

            self.request.sendall(str(p) + "\n")
            (key, secret) = fibCrypt.genKey(p)
            self.request.sendall(str(key[0][0]) + "," + str(key[0][1]) + "\n")

            parts = self.request.recv(200).split(",")
            theirKey = (int(parts[0]), int(parts[1]))

            shared = fibCrypt.calcM(p, secret, theirKey)
            mess = encrypt(FLAG, str(shared))
            self.request.sendall(mess + "\n")
            self.request.close()

Client:

    IV = "0123456789ABCDEF"

    def decrypt(text, passphrase):
        key = hashlib.sha256(passphrase).digest()
        aes = AES.new(key, AES.MODE_CBC, IV)
        return aes.decrypt(binascii.unhexlify(text))

    if __name__ == "__main__":
        HOST = sys.argv[1];
        PORT = int(sys.argv[2]);

        sock = socket.socket()
        sock.connect((HOST, PORT));

        p = int(read_until(sock, "\n"))
        (key, secret) = fibCrypt.genKey(p)
        sock.sendall(str(key[0][0]) + "," + str(key[0][1]) + "\n")

        parts = read_until(sock, "\n").split(",")
        theirKey = (int(parts[0]), int(parts[1]))

        shared = fibCrypt.calcM(p, secret, theirKey)
        text = sock.recv(200)
        print decrypt(text[:-1], str(shared))

Now we can see what data are exchanged

 1. the server sends a 64bits prime number
 2. both sides generate a pair (pub, priv) key and exchange their public part.
 3. both derivate an AES passphrase from the keys
 4. The server encrypts the flag and sends it to the client
 5. The client decrypts it

We have almost everything but the private part of the keys, of course we need it to decrypt the flag. Let's take a look at the fibCrypt library to see what kind of key and math they are using:

    def calcM(p, l, base):
        if l == 0:
            return [[base[1], base[0]], [base[0], base[1]]]
        x1 = [[base[0], base[1]], [base[1], (base[0] + base[1]) % p]]
        x2 = mult(x1, x1, p)
        for i in bin(l)[3:]:
            if i == '1':
                x1 = mult(x1, x2, p)
                x2 = mult(x2, x2, p)
            else:
                x2 = mult(x1, x2, p)
                x1 = mult(x1, x1, p)
        return x1

    def genKey(p):
        numBytes = int(math.ceil(math.log(p, 256)))
        exp = int(os.urandom(numBytes).encode('hex'), 16) % p
        r = calcM(p, exp, (0, 1))
        return (r, exp)

NOTE: mult is just a matrix multiplication modulo the parameter p.

In fact now we can see that the server/client are doing a Diffie-Hellman (DH) protocol in a fancier group that the basic integers. calcM is simply the fast exponentiation algorithm.

The group used is the

    group of 2 x 2 matrix modulo p generated by
    R =  ( 0 1 )
         ( 1 1 )

And the keys are in fact (R^s, s).

NOTE: like the matrix is in fact linked to Fibonacci, the pub key is only the fisrt row (k1, k2) because the second row is (k2, k1 + k2)

So we need to break DH, let's try to solve the discrete log, the prime number is only 64bits. Even if it is a matrix the strength can not be higher than a 256bits. Sage should be able to solve that easily:

    sage: p = 981725946171163877
    sage: k1 = 453665378628814896
    sage: k2 = 152333692332446539
    sage: F = GF(p)
    sage: e = matrix(F,[[0,1],[1,1]])
    sage: t = matrix(F, 2, [k1, k2, k2, (k1 + k2) % p])
    sage: discrete_log(t, e)
    /**** ERRORS ****/
    TypeError: mutable matrices are unhashable

The Small Step Giant Step algorithm keeps a hash table of result, but it tries to use the matrix as key. Unfortunately the mutable matrix are unhashable it seems s..
We were going to give up, but looking at the source code, we managed to put the matrix immutable.

    sage: discrete_log(t, e)
    152106608687469950

So we have now the private key of the client:

    with open("data.txt") as f:
        data = f.read().split("\n")

    p = int(data[0])
    ks1, ks2 = map(int, data[1].split(","))
    kc1, kc2 = map(int, data[2].split(","))
    ciphertext = data[3]
    secret = 152106608687469950

    shared = fibCrypt.calcM(p, secret, (ks1, ks2))
    print decrypt(ciphertext, str(shared))

###Flag: 9447{Pisan0_mU5t_nEv3r_hAve_THougHt_0f_bruTe_f0rce5}
